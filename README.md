# ЧАСТЬ 1: ЗАПУСК FLASK В КАЧЕСТВЕ САМОСТОЯТЕЛЬНОГО СЕРВЕРА
Dockerfile с реализацией Flask сервера переименован в Dockerfile_flask и игнорируется системой. По умолчанию используется образ описанный ниже в п.2.
Если все таки нужно запустить именно образ с Flask, то нужно обратно переименовать Dockerfile и пройтись по инструкции ниже.

Создание образа с именем flask_image:
```bash
docker build -t flask_image .
```

Запуск контейнера с именем server_container и публичным портом 5000 с помощью флага `-p` или `-public`:
```bash
docker run -it --rm --name=server_container -p=5000:5000 flask_image
``` 

Если нужно запустить в фоновом режиме тогда добавляем флаг `-d`:
```bash
docker run -it --rm -d --name=flask_container -p=5000:5000 flask_image
``` 

Чтобы проверить содержимое конейтнера нужно использовать эту команду:
```bash
$ docker exec -it flask_container bash
``` 

# ЧАСТЬ 2: ЗАПУСК СВЯЗКИ FLASK + UWSGI + NGINX + DOCKER
Связка UWSGI + NGINX позволяет одновременно запускать несколько потоков исполнения программ, чего Flask как сервер не умеет. Связка UWSGI + NGINX представляет собой мощный промышленный сервер, однако очень сложен в настройках. Однако существует популярный и проверенный docker образ, который уже настроен для работы с Flask. Нужно только подменить файл uwsgi.ini. Это делается следующим образом:
- создаем докер образ на основании образа tiangolo/uwsgi-nginx-flask (с указанием версии python)
- готовим локально свой uwsgi.ini (в нем указывается наше Flask приложение), пример ниже
- при сборке контейнера копируем этот файл в рабочую папке docker, тем самым подменяя уже существующий там файл, который использует main.py в качестве Flask приложения по умолчанию
  
Пример uwsgi.ini
```ini
[uwsgi]
module = server:app
processes = 4
master = true
```
Здесь в module указываем до двоеточния название нашего скрипта, а после двоеточния название нашего Flask приложения (переменной внутри кода)

Пример Dockerfile:
```yaml
# Задаём базовый образ
FROM tiangolo/uwsgi-nginx-flask:python3.10

WORKDIR /app

# Копируем файл requirements.txt в рабочую директорию контейнера
COPY ./requirements.txt ./
# Запускаем установку необходимых зависимостей
RUN pip install --no-cache-dir -r requirements.txt

# Копируем файл uwsgi.ini в рабочую директорию контейнера
COPY ./uwsgi.ini ./

# Копируем содержимое папки ./app в рабочую директорию контейнера
COPY ./app ./
```

После того, как у нас готово приложение (python скрипт с Flask), файл `uwsgi.ini` и `Dockerfile` собираем докер образ с именем *server_image*:
```bash
docker build -t server_image .
```

После того, как образ собран, запускаем контейнер:
```bash
docker run -it --rm --name=server_container -p=80:80 server_image
```

В результате объединения Flask, uWSGI и NGINX мы получили мощный веб-сервер, способный обрабатывать несколько запросов одновременно, обладающий высокой пропускной способностью, но, что самое важное — этот сервер функционирует в контейнере, а значит, мы легко можем переносить его с одной машины на другую, не беспокоясь о вопросах воспроизводимости и совместимости операционных систем.  Для этого нам достаточно разместить результирующий образ на Docker Hub, а затем с любой машины, на которой установлен Docker и есть интернет, можно скачать этот образ, собрать из него контейнер и запустить его.